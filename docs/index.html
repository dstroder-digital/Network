<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Primal Network — Interactive</title>
<link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet">
<script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
<script src="https://unpkg.com/pmtiles@3.0.6/dist/pmtiles.js"></script>
<style>
:root{--bg:#0b0b0b;--text:#eef5ff;--muted:#a8b3c7;--border:rgba(255,255,255,.12);--accent:#29adff;--gold:#ffcc00}
html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
#map{position:absolute;inset:0}
.hud{position:absolute;top:12px;left:12px;z-index:20;background:#0009;border:1px solid var(--border);border-radius:10px;padding:10px 12px}
.hud h3{margin:0 0 6px 0;font-size:15px} .hud small{color:var(--muted)}
.panel{position:absolute;top:12px;right:12px;z-index:20;width:min(370px,34vw);max-height:calc(100% - 24px);overflow:auto;background:#0009;border:1px solid var(--border);border-radius:12px;padding:12px}
.row{display:grid;grid-template-columns:110px 1fr;gap:10px;align-items:center}
.btnbar{display:flex;gap:6px;flex-wrap:wrap} .btn{padding:6px 10px;border:1px solid var(--border);border-radius:999px;background:#151515;color:var(--text);cursor:pointer;font-size:13px}
.btn.active{background:#1d2a36;border-color:#2c3a4b;color:#bfe1ff}
.legend{display:flex;gap:10px;align-items:center} .sw{width:24px;height:8px;border-radius:5px;background:var(--accent)} .sw.gold{background:var(--gold)}
.divider{height:1px;background:var(--border);margin:8px 0}
.stat{display:flex;justify-content:space-between;color:var(--muted)}
.props{font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12.5px}
.props table{width:100%;border-collapse:collapse} .props td{padding:4px 0;border-bottom:1px dashed var(--border);vertical-align:top}
.props td:first-child{color:var(--muted);padding-right:8px;width:42%}
.tip{position:absolute;pointer-events:none;z-index:30;transform:translate(-50%,-120%);background:#0e1116;color:#fff;padding:6px 8px;border:1px solid var(--border);border-radius:8px;white-space:nowrap;font-size:12.5px;box-shadow:0 10px 30px #0006}
.hidden{display:none}
select, input[type="range"]{width:100%}
label small{color:var(--muted)}
</style>
</head>
<body>
<div id="map"></div>

<div class="hud">
  <h3>Primal Network (PMTiles)</h3>
  <small>Pan/zoom; drag + <kbd>Alt</kbd> to rotate. Hover = preview, click = pin.</small>
</div>

<div class="panel">
  <div class="row">
    <label>Basemap</label>
    <div class="btnbar" id="basemapBar">
      <button class="btn" data-basemap="none">None</button>
      <button class="btn active" data-basemap="dark">Dark</button>
      <button class="btn" data-basemap="osm">OSM</button>
    </div>
  </div>

  <div class="row">
    <label>Edge color</label>
    <div class="btnbar" id="colorBar">
      <button class="btn active" data-color="solid">Solid</button>
      <button class="btn" data-color="count">By count</button>
      <button class="btn" data-color="class">By class</button>
      <button class="btn" data-color="metric" id="metricBtn" style="display:none">By metric</button>
    </div>
  </div>

  <div class="row" id="metricRow" style="display:none">
    <label>Metric <small>(if loaded)</small></label>
    <select id="metricSelect">
      <option value="degree">degree</option>
      <option value="betweenness">betweenness</option>
      <option value="closeness">closeness</option>
      <option value="pagerank">pagerank</option>
      <option value="community">community</option>
    </select>
  </div>

  <div class="row">
    <label>Min count</label>
    <input id="minCount" type="range" min="0" max="1000" step="1" value="0">
  </div>
  <div class="btnbar">
    <button class="btn" data-preset="0">All</button>
    <button class="btn" data-preset="5">5+</button>
    <button class="btn" data-preset="10">10+</button>
    <button class="btn" data-preset="50">50+</button>
    <button class="btn" data-preset="100">100+</button>
    <button class="btn" data-preset="250">250+</button>
  </div>

  <div class="btnbar" style="margin-top:6px">
    <button class="btn" id="toggleWeighted">Weighted overlay</button>
    <button class="btn" id="toggleNodes">Show nodes</button>
  </div>

  <div class="legend"><span class="sw"></span><small>Edges</small><span class="sw gold"></span><small>Weighted</small></div>
  <div class="divider"></div>

  <div class="stat"><span>Features in view</span><strong id="featCount">—</strong></div>
  <div class="stat"><span>Pinned id</span><strong id="pinnedId">—</strong></div>

  <div class="divider"></div>
  <div class="props" id="propTable">(click an edge to pin its properties)</div>
</div>

<div id="tip" class="tip hidden"></div>

<script>
(() => {
/* ---------- CONFIG: set your URLs ---------- */
const PMTILES_URL = 'pmtiles://https://media.githubusercontent.com/media/dstroder-digital/Network/main/docs/data/app/edges.pmtiles';
const NODES_URL   = 'https://dstroder-digital.github.io/Network/data/app/nodes.geojson';    // or pmtiles://… if you convert to pmtiles
const METRICS_URL = 'https://dstroder-digital.github.io/Network/data/app/edge_metrics.json'; // optional (see format below)

/* ---------- UI state ---------- */
const params = new URLSearchParams(location.search);
const state = {
  basemap: params.get('basemap') || 'dark',
  colorMode: params.get('color') || 'solid',
  minCount: +(params.get('min') ?? 0),
  metricName: 'degree',
  pinned: null,
  metrics: null, // { id -> {degree,betweenness,...} }
  metricDomain: [0,1],
  countDomain: [0,1000],
  weightedOn: false,
  nodesOn: false
};

/* ---------- PMTiles protocol (guarded) ---------- */
if (!window.__pmtilesProto) {
  window.__pmtilesProto = new pmtiles.Protocol();
  maplibregl.addProtocol('pmtiles', window.__pmtilesProto.tile);
}

/* ---------- Map ---------- */
const map = new maplibregl.Map({
  container: 'map',
  hash: true,
  pitchWithRotate: true,
  dragRotate: true,
  style: { version:8, sources:{}, layers:[
    { id:'background', type:'background', paint:{'background-color':'#0b0b0b'} }
  ]},
  center: [-80.8431, 35.2271],
  zoom: 10
});
map.addControl(new maplibregl.NavigationControl({visualizePitch:true}), 'top-right');
map.addControl(new maplibregl.ScaleControl({maxWidth:160, unit:'imperial'}));

/* ---------- Source-layer autodetect ---------- */
let SOURCE_LAYER = 'edges';
const tiles = new pmtiles.PMTiles(PMTILES_URL.replace('pmtiles://',''));
tiles.getMetadata().then(meta=>{
  const names = (meta?.vector_layers||[]).map(v=>v.id);
  if (names.length && !names.includes(SOURCE_LAYER)) SOURCE_LAYER = names[0];
  // If metadata has count summary, use it
  const cmin = meta?.tilestats?.layers?.find(l=>l.layer===SOURCE_LAYER)?.attributes?.find(a=>a.attribute==='count')?.min;
  const cmax = meta?.tilestats?.layers?.find(l=>l.layer===SOURCE_LAYER)?.attributes?.find(a=>a.attribute==='count')?.max;
  if (Number.isFinite(cmax)) { state.countDomain=[0, Math.max(10,cmax)]; document.getElementById('minCount').max = String(state.countDomain[1]); }
}).catch(console.warn);

/* ---------- Metrics (optional JSON) ----------
   Format: an array or object keyed by edge id.
   Example JSON:
   {
     "49263": {"degree":4,"betweenness":0.0021,"closeness":0.31,"pagerank":0.00042,"community":12},
     "104882": {...}
   }
*/
fetch(METRICS_URL,{mode:'cors'}).then(r=> r.ok ? r.json() : null).then(j=>{
  if (!j) return;
  state.metrics = Array.isArray(j) ? Object.fromEntries(j.map(o=>[String(o.id),o])) : j;
  // enable metric UI
  document.getElementById('metricBtn').style.display='';
  document.getElementById('metricRow').style.display='';
  // estimate domain for default metric
  setMetricDomain();
}).catch(()=>{ /* metrics optional */ });

function setMetricDomain(){
  if (!state.metrics) return;
  const vals = [];
  for (const k in state.metrics) {
    const v = +state.metrics[k]?.[state.metricName];
    if (Number.isFinite(v)) vals.push(v);
  }
  if (vals.length) {
    vals.sort((a,b)=>a-b);
    const lo = vals[Math.floor(vals.length*0.02)];
    const hi = vals[Math.floor(vals.length*0.98)];
    state.metricDomain = [lo, hi];
  }
}

/* ---------- Colors & painters ---------- */
const ramps = {
  solid: '#29adff',
  count: ['interpolate', ['linear'], ['coalesce',['to-number',['get','count']],0],
    0,'#24496b', 10,'#2f6f9b', 50,'#3e8ec3', 100,'#55b0ec', 250,'#9ad0ff', 500,'#cfe6ff'],
  class: ['match', ['downcase',['coalesce',['get','functional_class'],'']],
    'motorway','#ff7a00','trunk','#ffcc00','primary','#ffd34d','secondary','#66d17a',
    'tertiary','#8bd7a2','residential','#29adff','service','#b1b8c7','#29adff']
};

function metricColorExpr(){
  // map metric to feature-state (set on-the-fly) or fall back to property if baked-in
  return ['interpolate',['linear'], ['coalesce',
           ['feature-state', state.metricName],
           ['to-number',['get', state.metricName]], 0],
    state.metricDomain[0], '#264653',
    (state.metricDomain[0]+state.metricDomain[1])/2, '#2a9d8f',
    state.metricDomain[1], '#e9c46a'
  ];
}

function edgePaint(){
  const color = state.colorMode==='metric' ? metricColorExpr()
              : ramps[state.colorMode] || ramps.solid;
  return {
    'line-color': color,
    'line-width': ['interpolate',['linear'],['zoom'],
      8, ['max',0.3,['*',0.008,['sqrt',['coalesce',['to-number',['get','count']],0]]]],
      12,['max',1.0,['*',0.02,['sqrt',['coalesce',['to-number',['get','count']],0]]]],
      15,['max',2.0,['*',0.04,['sqrt',['coalesce',['to-number',['get','count']],0]]]]
    ],
    'line-opacity': 0.9
  };
}
const filterMin = () => ['>=', ['coalesce',['to-number',['get','count']],0], state.minCount];

/* ---------- Build map ---------- */
map.on('load', ()=>{
  addBasemap(state.basemap);

  map.addSource('edges', { type:'vector', url: PMTILES_URL });
  map.addLayer({ id:'edges-line', type:'line', source:'edges', 'source-layer':SOURCE_LAYER, layout:{'line-cap':'round','line-join':'round'}, paint: edgePaint(), filter: filterMin() });

  map.addLayer({ id:'edges-weighted', type:'line', source:'edges', 'source-layer':SOURCE_LAYER,
    layout:{'line-cap':'round','line-join':'round'}, paint:{'line-color':'#ffcc00','line-opacity':0.55,'line-width':[
      'interpolate',['linear'],['coalesce',['to-number',['get','count']],0],
      50,1.5, 100,2.5, 250,4, 500,6, 1000,10
    ]}, filter:['all', filterMin(), ['>=',['coalesce',['to-number',['get','count']],0], 250]], visibility:'none'
  });

  // Nodes (toggle)
  map.addSource('nodes', { type:'geojson', data: NODES_URL });
  map.addLayer({ id:'nodes-circle', type:'circle', source:'nodes',
    paint:{
      'circle-radius': ['interpolate',['linear'],['zoom'], 8,1.2, 12,2.2, 15,3.2],
      'circle-color': '#f4a261', 'circle-opacity': 0.75
    }, layout:{ visibility:'none' }
  });

  // Initial slider max from rendered data if no tilestats
  setTimeout(sampleCountRange, 400);

  hookUI();
  updateCountsDebounced();
});

/* ---------- Basemap helpers ---------- */
function addBasemap(mode){
  ['osm','darkTiles'].forEach(id=>{
    try{ if(map.getLayer(id)) map.removeLayer(id);}catch(e){}
    try{ if(map.getSource(id)) map.removeSource(id);}catch(e){}
  });
  if (mode==='none') return;
  if (mode==='osm') {
    map.addSource('osm',{type:'raster',tiles:['https://tile.openstreetmap.org/{z}/{x}/{y}.png'],tileSize:256,attribution:'© OpenStreetMap'});
    map.addLayer({id:'osm',type:'raster',source:'osm'}, 'edges-line');
  } else {
    map.addSource('darkTiles',{type:'raster',tiles:['https://tiles.stadiamaps.com/tiles/alidade_smooth_dark/{z}/{x}/{y}.png'],tileSize:256,attribution:'© Stadia Maps, © OpenMapTiles, © OpenStreetMap'});
    map.addLayer({id:'darkTiles',type:'raster',source:'darkTiles'}, 'edges-line');
  }
}

/* ---------- UI wiring ---------- */
function hookUI(){
  // basemap
  document.getElementById('basemapBar').addEventListener('click', e=>{
    const btn=e.target.closest('button'); if(!btn) return;
    state.basemap = btn.dataset.basemap;
    setActive(e.currentTarget, btn); addBasemap(state.basemap); pushUrl();
  });

  // color
  const colorBar = document.getElementById('colorBar');
  colorBar.addEventListener('click', e=>{
    const btn=e.target.closest('button'); if(!btn) return;
    state.colorMode = btn.dataset.color;
    setActive(colorBar, btn);
    if (map.getLayer('edges-line')) map.setPaintProperty('edges-line','line-color', state.colorMode==='metric'? metricColorExpr(): (ramps[state.colorMode]||ramps.solid));
    pushUrl();
  });

  // metric select
  document.getElementById('metricSelect').addEventListener('change', e=>{
    state.metricName = e.target.value; setMetricDomain();
    if (state.colorMode==='metric' && map.getLayer('edges-line')) map.setPaintProperty('edges-line','line-color', metricColorExpr());
  });

  // min slider + presets
  const slider = document.getElementById('minCount');
  slider.min = String(state.countDomain[0]); slider.max = String(state.countDomain[1]); slider.value = String(state.minCount);
  slider.addEventListener('input', e=>{
    state.minCount = +e.target.value; applyFilters(); updateCountsDebounced(); pushUrl();
  });
  document.querySelectorAll('[data-preset]').forEach(b=>b.addEventListener('click', ()=>{
    state.minCount = +b.dataset.preset; slider.value = String(state.minCount); applyFilters(); updateCountsDebounced(); pushUrl();
  }));

  // toggles
  document.getElementById('toggleWeighted').addEventListener('click', (e)=>{
    state.weightedOn = !state.weightedOn;
    map.setLayoutProperty('edges-weighted','visibility', state.weightedOn?'visible':'none');
    e.currentTarget.classList.toggle('active', state.weightedOn);
  });
  document.getElementById('toggleNodes').addEventListener('click', (e)=>{
    state.nodesOn = !state.nodesOn;
    map.setLayoutProperty('nodes-circle','visibility', state.nodesOn?'visible':'none');
    e.currentTarget.classList.toggle('active', state.nodesOn);
  });

  // reveal metric button if metrics loaded
  if (state.metrics) {
    document.getElementById('metricBtn').style.display='';
    document.getElementById('metricRow').style.display='';
  }
}

/* ---------- Filters / counts ---------- */
function applyFilters(){
  if (map.getLayer('edges-line')) map.setFilter('edges-line', filterMin());
  if (map.getLayer('edges-weighted')) map.setFilter('edges-weighted', ['all', filterMin(), ['>=',['coalesce',['to-number',['get','count']],0],250]]);
}
const featCountEl = document.getElementById('featCount');
const updateCountsDebounced = debounce(()=>{
  const bbox=[[0,0],[map.getCanvas().width, map.getCanvas().height]];
  const feats = map.queryRenderedFeatures(bbox,{layers:['edges-line']});
  featCountEl.textContent = feats.length.toLocaleString();
  // set feature-state metrics for visible features (if we have a metrics index)
  if (state.metrics && feats.length) {
    for (const f of feats) {
      const id = (f.id ?? f.properties?.id ?? null);
      if (id==null) continue;
      const m = state.metrics[id] || state.metrics[String(id)];
      if (!m) continue;
      map.setFeatureState({source:'edges',sourceLayer:SOURCE_LAYER,id:f.id}, m);
    }
  }
}, 250);
['moveend','zoomend','dragend','rotateend','pitchend','idle'].forEach(ev=>map.on(ev, updateCountsDebounced));

/* ---------- Tooltip + Property table (clean) ---------- */
const tipEl = document.getElementById('tip');
const propsEl = document.getElementById('propTable');
const pinnedEl = document.getElementById('pinnedId');

// field whitelist + label map + formatters
const FIELD_LABELS = {
  id:'id', name:'name', ref:'ref', count:'count', functional_class:'class',
  oneway:'oneway', maxspeed:'maxspeed', lanes:'lanes', surface:'surface',
  divided:'divided', hovlane:'hovlane', e911:'e911', l_zipcode:'zipcode', lasteditda:'last_edited'
};
const FORMAT = {
  oneway: v => v===1||v==='1'||String(v).toLowerCase()==='yes' ? 'yes' : (v===0||v==='0'?'no':v),
  divided: v => v? 'yes':'no',
  last_edited: v => /^\d{4}-\d{2}-\d{2}/.test(v) ? v.slice(0,10) : v,
  maxspeed: v => v? `${v} mph` : ''
};

function cleanProps(raw){
  const out = {};
  for (const k in FIELD_LABELS) {
    const srcKey = k; const label = FIELD_LABELS[k];
    let v = raw?.[srcKey];
    if (v==null || v==='') continue;
    if (FORMAT[label]) v = FORMAT[label](v);
    out[label] = v;
  }
  return out;
}

map.on('mousemove', e=>{
  const f = map.queryRenderedFeatures(e.point,{layers:['edges-line','edges-weighted']})[0];
  if(!f || state.pinned){ tipEl.classList.add('hidden'); return; }
  const id = f.id ?? f.properties?.id ?? '';
  const nm = f.properties?.name || f.properties?.ref || 'Edge';
  const cnt = +f.properties?.count;
  tipEl.innerHTML = `<strong>${esc(nm)}</strong>${Number.isFinite(cnt)?` — count: ${cnt}`:''}${id?`<br><small>#${esc(id)}</small>`:''}`;
  tipEl.style.left = e.originalEvent.clientX+'px';
  tipEl.style.top  = e.originalEvent.clientY+'px';
  tipEl.classList.remove('hidden');
});
map.on('mouseleave','edges-line',()=>{ if(!state.pinned) tipEl.classList.add('hidden'); });
map.on('mouseleave','edges-weighted',()=>{ if(!state.pinned) tipEl.classList.add('hidden'); });
map.on('click', e=>{
  const f = map.queryRenderedFeatures(e.point,{layers:['edges-line','edges-weighted']})[0];
  if(!f){ state.pinned=null; tipEl.classList.add('hidden'); pinnedEl.textContent='—'; propsEl.textContent='(click an edge to pin its properties)'; return; }
  state.pinned = f;
  pinnedEl.textContent = f.id ?? f.properties?.id ?? '—';
  const props = cleanProps(f.properties||{});
  propsEl.innerHTML = renderTable(props);
});

/* ---------- Helpers ---------- */
function setActive(container, btn){ [...container.querySelectorAll('.btn')].forEach(b=>b.classList.toggle('active',b===btn)); }
function esc(s){return String(s).replace(/[&<>"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));}
function renderTable(obj){const k=Object.keys(obj); if(!k.length) return '(no selected fields)'; let h='<table>'; for(const x of k){ h+=`<tr><td>${esc(x)}</td><td>${esc(obj[x])}</td></tr>` } return h+'</table>';}
function debounce(fn,wait){let t; return(...a)=>{clearTimeout(t); t=setTimeout(()=>fn(...a),wait)}}
function pushUrl(){const p=new URLSearchParams(location.search); p.set('basemap',state.basemap); p.set('color',state.colorMode); p.set('min',state.minCount); history.replaceState(null,'',`${location.pathname}?${p.toString()}${location.hash}`);}

function sampleCountRange(){
  // sample visible features to set a sensible max for the slider if tilestats didn't
  const bbox=[[0,0],[map.getCanvas().width, map.getCanvas().height]];
  const feats = map.queryRenderedFeatures(bbox,{layers:['edges-line']});
  const vals = feats.map(f=>+f.properties?.count).filter(Number.isFinite);
  if (!vals.length) return;
  vals.sort((a,b)=>a-b);
  const hi = vals[Math.floor(vals.length*0.98)];
  state.countDomain=[0, Math.max(10, hi)];
  const slider = document.getElementById('minCount');
  slider.max = String(state.countDomain[1]);
  if (state.minCount>state.countDomain[1]) { state.minCount=0; slider.value='0'; applyFilters(); }
}

/* ---------- Metric coloring: set feature-state from index ---------- */
map.on('render', throttle(()=>{
  if (!state.metrics || state.colorMode!=='metric') return;
  const bbox=[[0,0],[map.getCanvas().width, map.getCanvas().height]];
  const feats = map.queryRenderedFeatures(bbox,{layers:['edges-line']});
  for (const f of feats) {
    const id = f.id ?? f.properties?.id;
    if (id==null) continue;
    const m = state.metrics[id] || state.metrics[String(id)];
    if (!m) continue;
    map.setFeatureState({source:'edges',sourceLayer:SOURCE_LAYER,id:f.id}, m);
  }
}, 400));

function throttle(fn,wait){let t=0;return(...a)=>{const now=Date.now();if(now-t>wait){t=now;fn(...a);}}}

/* ---------- Errors ---------- */
map.on('error', e=>console.error('Map error:', e?.error||e));
})();
</script>
</body>
</html>
