<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Primal Network — Charlotte</title>

<link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet">
<script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
<script src="https://unpkg.com/pmtiles@3.0.6/dist/pmtiles.js"></script>
<script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

<style>
:root{
  --bg:#0b0b0b; --panel:#0009; --border:rgba(255,255,255,.12); --text:#eef5ff; --muted:#a8b3c7;
}
html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
#map{position:absolute;inset:0}
.hud{position:absolute;top:12px;left:12px;z-index:20;background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:10px 12px}
.hud h3{margin:0 0 6px 0;font-size:15px}.hud small{color:var(--muted)}
.panel{position:absolute;top:12px;right:12px;z-index:20;width:min(520px,42vw);max-height:calc(100% - 24px);overflow:auto;background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:12px}
.row{display:grid;grid-template-columns:140px 1fr;gap:10px;align-items:center}
.btn{padding:6px 10px;border:1px solid var(--border);border-radius:999px;background:#151515;color:var(--text);cursor:pointer;font-size:13px}
.btn.active{background:#1d2a36;border-color:#2c3a4b;color:#bfe1ff}
.legend{display:flex;gap:10px;align-items:center;margin-top:6px;flex-wrap:wrap}
.sw{width:24px;height:8px;border-radius:5px;background:#29adff}
.sw.r1{background:#ffd34d}.sw.r2{background:#9ae6b4}
.sw.fire{background:#ff8a00}.sw.med{background:#e76f51}
.sw.flood{background:#38bdf8}.sw.future{background:#22d3ee}
.divider{height:1px;background:var(--border);margin:8px 0}
.props{font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12.5px}
.props table{width:100%;border-collapse:collapse}
.props td{padding:4px 0;border-bottom:1px dashed var(--border);vertical-align:top}
.props td:first-child{color:var(--muted);padding-right:8px;width:42%}
a{color:#9ad0ff;text-decoration:none} a:hover{text-decoration:underline}
.tip{position:absolute;pointer-events:none;z-index:30;transform:translate(-50%,-120%);background:#0e1116;color:#fff;padding:6px 8px;border:1px solid var(--border);border-radius:8px;white-space:nowrap;font-size:12.5px;box-shadow:0 10px 30px #0006}
.hidden{display:none}
.range{width:100%}
.small{color:var(--muted);font-size:12px}
.details{background:#0e111670;border:1px solid var(--border);border-radius:10px;padding:8px}
summary{cursor:pointer}
.badge{display:inline-block;padding:2px 8px;border:1px solid var(--border);border-radius:999px;background:#151515;margin-left:6px;font-size:12px;color:#cde7ff}
</style>
</head>
<body>
<div id="map"></div>

<div class="hud">
  <h3>Primal Network (PMTiles)</h3>
  <small>Pan/zoom; drag + <kbd>Alt</kbd> to rotate. Hover = preview, click = set rescue point.</small>
</div>

<div class="panel">
  <div class="row">
    <label>Flood overlays</label>
    <div>
      <button class="btn" id="toggleNFHL">NFHL</button>
      <button class="btn" id="toggleFuture">Future</button>
    </div>
  </div>
  <div class="row">
    <label>Flood opacity</label>
    <input class="range" type="range" id="floodOpacity" min="0" max="1" step="0.05" value="0.35">
  </div>

  <div class="divider"></div>

  <div class="row">
    <label>Edge color</label>
    <div>
      <button class="btn active" id="colorMetric">By ebetweenness</button>
      <button class="btn" id="colorWeight">By weight</button>
      <span class="small">Routing note: OSRM uses its own profile; your custom weights affect only coloring unless you run OSRM with a custom profile.</span>
    </div>
  </div>

  <div class="divider"></div>

  <div class="details">
    <b>Rescue planner</b>
    <div class="small">Click map to set a rescue location. We’ll route to the most feasible <b>Fire</b> station, then to the most feasible <b>Medical</b> facility in one step (OSRM; prefers routes avoiding visible flood layers).</div>
    <div id="rescueInfo" class="small" style="margin-top:8px"></div>
  </div>

  <div class="divider"></div>
  <div class="legend">
    <span class="sw"></span><small>Edges</small>
    <span class="sw r1"></span><small>Rescue → Fire</small>
    <span class="sw r2"></span><small>Fire → Medical</small>
    <span class="sw fire"></span><small>Fire stations</small>
    <span class="sw med"></span><small>Medical facilities</small>
    <span class="sw flood"></span><small>NFHL</small>
    <span class="sw future"></span><small>Future flood</small>
  </div>

  <div class="divider"></div>
  <details>
    <summary>Fields (from tiles)</summary>
    <div id="fieldsList" class="small" style="margin-top:6px"></div>
  </details>

  <div class="divider"></div>
  <div class="props" id="propTable">(click an edge to pin its properties) — <a href="#" id="toggleRaw">show raw</a></div>
</div>

<div id="tip" class="tip hidden"></div>

<script>
(() => {
/* ---------------- Data URLs ---------------- */
const PMTILES_URL = 'pmtiles://https://media.githubusercontent.com/media/dstroder-digital/Network/main/docs/data/app/edges.pmtiles';
const NODES_URL   = 'https://dstroder-digital.github.io/Network/data/app/nodes.geojson';
const FIRE_URL    = 'https://dstroder-digital.github.io/Network/data/app/fire_stations.geojson';
const MED_URL     = 'https://dstroder-digital.github.io/Network/data/app/medical_facilities.geojson';
const NFHL_URL    = 'https://dstroder-digital.github.io/Network/data/app/nfhl_dissolved.geojson';
const FUTURE_URL  = 'https://dstroder-digital.github.io/Network/data/app/future_flood_dissolved.geojson';
const METRICS_URL = 'https://dstroder-digital.github.io/Network/data/app/edge_metrics.json'; // JSON export from parquet
const JSON_ID_FIELD = 'eid'; // your JSON shows 'eid' in screenshot

/* -------- Routing (OSRM): change to your own server for production -------- */
const OSRM_BASE = 'https://router.project-osrm.org';

/* -------- PMTiles protocol guard -------- */
if (!window.__pmtilesProto) {
  window.__pmtilesProto = new pmtiles.Protocol();
  maplibregl.addProtocol('pmtiles', window.__pmtilesProto.tile);
}

/* -------- Map + dark basemap -------- */
const map = new maplibregl.Map({
  container:'map', hash:true, pitchWithRotate:true, dragRotate:true,
  style:{version:8, sources:{}, layers:[{id:'bg',type:'background',paint:{'background-color':'#0b0b0b'}}]},
  center:[-80.8431,35.2271], zoom:11
});
map.addControl(new maplibregl.NavigationControl({visualizePitch:true}), 'top-right');
map.addControl(new maplibregl.ScaleControl({maxWidth:160, unit:'imperial'}));
map.on('load',()=> {
  map.addSource('dark',{type:'raster',tiles:['https://tiles.stadiamaps.com/tiles/alidade_smooth_dark/{z}/{x}/{y}.png'],tileSize:256,attribution:'© Stadia Maps, © OpenMapTiles, © OpenStreetMap'});
  map.addLayer({id:'dark',type:'raster',source:'dark'}, 'bg');
});

/* -------- Icons & arrows -------- */
const arrowSvg='data:image/svg+xml;base64,'+btoa(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white"><path d="M13 5l7 7-7 7v-4H4v-6h9V5z"/></svg>`);
const fireTruck='data:image/svg+xml;base64,'+btoa(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><g fill="#ff8a00"><path d="M7 34h30l8-10h9v16H7z"/><circle cx="19" cy="44" r="6" fill="#fff"/><circle cx="45" cy="44" r="6" fill="#fff"/><circle cx="19" cy="44" r="3" fill="#111"/><circle cx="45" cy="44" r="3" fill="#111"/></g><rect x="40" y="24" width="6" height="6" fill="#fff"/></svg>`);
const medical='data:image/svg+xml;base64,'+btoa(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="12" y="28" width="40" height="8" rx="2" fill="#e76f51"/><rect x="28" y="12" width="8" height="40" rx="2" fill="#e76f51"/><path d="M36 22c4 0 8 2 8 6s-4 6-8 6c-3 0-6 1-6 4 0 3 3 4 6 4" stroke="#fff" stroke-width="2" fill="none"/></svg>`);
let iconOk = { fire:false, med:false };
map.on('load',()=>{
  map.loadImage(arrowSvg,(e,img)=>{ if(!e) map.addImage('arrow',img,{pixelRatio:2}); });
  map.loadImage(fireTruck,(e,img)=>{ if(!e){ map.addImage('firetruck',img,{pixelRatio:2}); iconOk.fire=true; }});
  map.loadImage(medical,(e,img)=>{ if(!e){ map.addImage('medicon',img,{pixelRatio:2}); iconOk.med=true; }});
});

/* -------- Tile field discovery -------- */
let SOURCE_LAYER='edges';
const fieldsUI=document.getElementById('fieldsList');
const tiles = new pmtiles.PMTiles(PMTILES_URL.replace('pmtiles://',''));
tiles.getMetadata().then(meta=>{
  const names=(meta?.vector_layers||[]).map(v=>v.id);
  if(names.length && !names.includes(SOURCE_LAYER)) SOURCE_LAYER=names[0];
  const attrs=(meta?.tilestats?.layers||[]).find(l=>l.layer===SOURCE_LAYER)?.attributes||[];
  if (attrs.length){ fieldsUI.innerHTML=attrs.map(a=>`• <code>${a.attribute}</code> <span class="small">(${a.type||'?'})</span>`).join('<br>'); }
}).catch(()=>{});

/* -------- Build core layers -------- */
let fireFC=null, medFC=null, nfhlFC=null, futureFC=null, metricMap=null;
let colorMode='metric'; // 'metric' | 'weight'

map.on('load', async ()=>{
  // edges
  map.addSource('edges',{type:'vector',url:PMTILES_URL});
  map.addLayer({id:'edges-line',type:'line',source:'edges','source-layer':SOURCE_LAYER,
    layout:{'line-cap':'round','line-join':'round'},
    paint:{
      'line-color':'#29adff', /* overridden by color mode */
      'line-opacity':0.95,
      'line-width':['interpolate',['linear'],['zoom'], 8,0.6, 12,1.3, 15,2.2]
    }
  });

  // one-way arrows
  map.addLayer({id:'oneway-arrows',type:'symbol',source:'edges','source-layer':SOURCE_LAYER,
    layout:{'symbol-placement':'line','symbol-spacing':60,'icon-image':'arrow','icon-size':0.55,'visibility':'visible'},
    filter:['any',
      ['==',['downcase',['get','oneway']],'yes'],
      ['==',['downcase',['get','one_way']],'yes'],
      ['==',['downcase',['get','is_oneway']],'yes'],
      ['==',['downcase',['get','direction']],'one-way'],
      ['==',['downcase',['get','dir']],'one-way'],
      ['in',['to-string',['get','oneway']],['literal',['1','true','True','y','Y','Yes']]]
    ],
    paint:{'icon-opacity':0.9}
  });

  // nodes
  try{
    const nodes = await (await fetch(NODES_URL)).json();
    map.addSource('nodes',{type:'geojson',data:nodes});
    map.addLayer({id:'nodes',type:'circle',source:'nodes',
      paint:{'circle-radius':['interpolate',['linear'],['zoom'],8,1.0,12,1.8,15,2.4],
             'circle-color':'#f4a261','circle-opacity':0.35,'circle-stroke-color':'#111','circle-stroke-width':0.5}});
    console.log('Nodes loaded:', nodes.features?.length ?? 0);
  }catch(err){ console.warn('Nodes failed:', err); }

  await addPOIs();
  await loadFloods();
  await loadMetrics();      // enables metric coloring
  setColorMode('metric');   // start with ebetweenness
  addRescueGraphics();      // routes & point layers
  wireUI();
});

/* -------- Fire & Medical (always visible; med filtered to named) -------- */
async function addPOIs(){
  try{
    fireFC = await (await fetch(FIRE_URL)).json();
    console.log('Fire stations:', fireFC.features?.length ?? 0);
    map.addSource('fire',{type:'geojson',data:fireFC});
    // icon layer (if icon loaded)
    map.addLayer({id:'fire-ic',type:'symbol',source:'fire',layout:{
      'icon-image':'firetruck','icon-size':['interpolate',['linear'],['zoom'],8,0.7,12,0.9,15,1.05],
      'icon-allow-overlap':true,'text-field':['coalesce',['get','name'],'Fire station'],
      'text-font':['Open Sans Semibold','Arial Unicode MS Bold'],'text-size':11,'text-offset':[0,1.1],
      'text-anchor':'top','visibility': iconOk.fire?'visible':'none'
    },paint:{'text-halo-color':'#000','text-halo-width':1.2}});
    // circle fallback (always visible; mostly redundant when icons present)
    map.addLayer({id:'fire-pt',type:'circle',source:'fire',
      paint:{'circle-radius':['interpolate',['linear'],['zoom'],8,3,12,4.5,15,6],
             'circle-color':'#ff8a00','circle-stroke-color':'#111','circle-stroke-width':1,
             'circle-opacity': iconOk.fire?0.3:0.9 }});
  }catch(err){ console.warn('Fire stations failed:', err); }

  try{
    const medAll = await (await fetch(MED_URL)).json();
    medFC = {type:'FeatureCollection',features:(medAll.features||[]).filter(f=>(f.properties?.name||'').trim().length>0)};
    console.log('Medical facilities (named):', medFC.features?.length ?? 0);
    map.addSource('med',{type:'geojson',data:medFC});
    map.addLayer({id:'med-ic',type:'symbol',source:'med',layout:{
      'icon-image':'medicon','icon-size':['interpolate',['linear'],['zoom'],8,0.7,12,0.9,15,1.05],
      'icon-allow-overlap':true,'text-field':['get','name'],
      'text-font':['Open Sans Semibold','Arial Unicode MS Bold'],'text-size':11,'text-offset':[0,1.1],
      'text-anchor':'top','visibility': iconOk.med?'visible':'none'
    },paint:{'text-halo-color':'#000','text-halo-width':1.2}});
    map.addLayer({id:'med-pt',type:'circle',source:'med',
      paint:{'circle-radius':['interpolate',['linear'],['zoom'],8,3,12,4.5,15,6],
             'circle-color':'#e76f51','circle-stroke-color':'#111','circle-stroke-width':1,
             'circle-opacity': iconOk.med?0.3:0.9 }});
  }catch(err){ console.warn('Medical facilities failed:', err); }
}

/* -------- Flood overlays -------- */
async function loadFloods(){
  try{ nfhlFC = await (await fetch(NFHL_URL)).json();
       map.addSource('nfhl',{type:'geojson',data:nfhlFC});
       map.addLayer({id:'nfhl',type:'fill',source:'nfhl',layout:{visibility:'none'},
         paint:{'fill-color':'#38bdf8','fill-opacity':0.35,'fill-outline-color':'#0ea5e9'}});}catch(err){ console.warn('NFHL failed:', err); }
  try{ futureFC = await (await fetch(FUTURE_URL)).json();
       map.addSource('future',{type:'geojson',data:futureFC});
       map.addLayer({id:'future',type:'fill',source:'future',layout:{visibility:'none'},
         paint:{'fill-color':'#22d3ee','fill-opacity':0.35,'fill-outline-color':'#06b6d4'}});}catch(err){ console.warn('Future flood failed:', err); }
}

/* -------- Metrics (ebetweenness) -------- */
async function loadMetrics(){
  try{
    const arr = await (await fetch(METRICS_URL,{mode:'cors'})).json(); // [{eid, ebetweenness, weight, ...}]
    metricMap = new Map(arr.map(o => [ String(o[JSON_ID_FIELD]), +o.ebetweenness ]));
    // store weights too for weight mode
    weightMap  = new Map(arr.map(o => [ String(o[JSON_ID_FIELD]), +o.weight ]));
    console.log('Metrics loaded:', metricMap.size, 'weights:', weightMap.size);

    // attach metric state on render (viewport join)
    map.on('render', throttle(()=>{
      const bbox=[[0,0],[map.getCanvas().width, map.getCanvas().height]];
      const feats=map.queryRenderedFeatures(bbox,{layers:['edges-line']});
      for(const f of feats){
        const eid = f.properties?.eid ?? f.properties?.id;
        const m = metricMap.get(String(eid));
        const w = weightMap.get(String(eid));
        // stash both in feature-state; used by color mode
        map.setFeatureState({source:'edges',sourceLayer:SOURCE_LAYER,id:f.id},{m: (typeof m==='number'?m:null), w: (typeof w==='number'?w:null)});
      }
    }, 400));
  }catch(err){
    console.warn('Metrics JSON not loaded — edges will stay solid or weight mode limited.', err);
  }
}
let weightMap = new Map();

/* -------- Color modes -------- */
function setColorMode(mode){
  colorMode = mode;
  document.getElementById('colorMetric').classList.toggle('active', mode==='metric');
  document.getElementById('colorWeight').classList.toggle('active', mode==='weight');

  if(mode==='metric'){
    map.setPaintProperty('edges-line','line-color',
      ['interpolate',['linear'],['coalesce',['feature-state','m'],0],
        0,'#264653', 0.33,'#2a9d8f', 0.66,'#e9c46a', 1,'#f4a261'
      ]);
  }else{
    // Normalize weight approx: clip to [0, 300] then map
    map.setPaintProperty('edges-line','line-color',
      ['interpolate',['linear'],
        ['min',300, ['max',0, ['coalesce',['feature-state','w'], ['to-number',['get','weight'],0] ] ] ],
        0,'#293241', 100,'#5a9fd6', 200,'#7bdcb5', 300,'#fcca46'
      ]);
  }
}
function wireUI(){
  document.getElementById('colorMetric').onclick=()=>setColorMode('metric');
  document.getElementById('colorWeight').onclick=()=>setColorMode('weight');
}

/* -------- Rescue routing pipeline -------- */
function addRescueGraphics(){
  map.addSource('rescue_pt',{type:'geojson',data:turf.featureCollection([])});
  map.addLayer({id:'rescue_pt',type:'circle',source:'rescue_pt',paint:{'circle-radius':6,'circle-color':'#ffffff','circle-stroke-color':'#111','circle-stroke-width':1}});
  map.addSource('route_fire',{type:'geojson',data:turf.featureCollection([])});
  map.addLayer({id:'route_fire',type:'line',source:'route_fire',paint:{'line-color':'#ffd34d','line-width':4}});
  map.addSource('route_med',{type:'geojson',data:turf.featureCollection([])});
  map.addLayer({id:'route_med',type:'line',source:'route_med',paint:{'line-color':'#9ae6b4','line-width':4}});
}

const rescueInfo=document.getElementById('rescueInfo');
let rescuePt=null;

map.on('click', async (e)=>{
  // clicking an edge shows table; clicking empty sets rescue point
  const feats = map.queryRenderedFeatures(e.point,{layers:['edges-line']});
  if (feats.length){ lastProps=feats[0].properties||{}; lastPinned=true; propsEl.innerHTML=renderTable(cleanProps(lastProps)); return; }

  rescuePt=[e.lngLat.lng,e.lngLat.lat];
  map.getSource('rescue_pt').setData(turf.featureCollection([turf.point(rescuePt)]));

  const avoidPolys = (map.getLayoutProperty('nfhl','visibility')==='visible' || map.getLayoutProperty('future','visibility')==='visible')
    ? [...(nfhlFC?.features||[]), ...(futureFC?.features||[])] : [];

  // choose fire → then medical (prefer outside visible flood)
  const fireChoice = pickFacility(rescuePt, fireFC, avoidPolys);
  const fireCoord = fireChoice?.feature?.geometry?.coordinates;
  const medChoice = fireCoord ? pickFacility(fireCoord, medFC, avoidPolys) : null;

  // route with OSRM (minimize flooded overlap)
  const A = fireChoice?.feature ? await routeOSRM(rescuePt, fireChoice.feature.geometry.coordinates, avoidPolys) : null;
  const B = (fireCoord && medChoice?.feature) ? await routeOSRM(fireCoord, medChoice.feature.geometry.coordinates, avoidPolys) : null;

  map.getSource('route_fire').setData(A? turf.featureCollection([A.geom]) : turf.featureCollection([]));
  map.getSource('route_med').setData(B? turf.featureCollection([B.geom]) : turf.featureCollection([]));

  const reasonA = A ? A.reason : 'no route found';
  const reasonB = B ? B.reason : 'no route found';
  const nameA = fireChoice?.feature?.properties?.name || 'Fire Station';
  const nameB = medChoice?.feature?.properties?.name || 'Medical facility';

  rescueInfo.innerHTML =
    `<b>Rescue → Fire:</b> ${esc(nameA)} — ${A?A.dist.toFixed(2)+' mi, '+Math.round(A.eta)+' min':'n/a'} (reason: ${reasonA}).<br>`+
    `<b>Fire → Medical:</b> ${esc(nameB)} — ${B?B.dist.toFixed(2)+' mi, '+Math.round(B.eta)+' min':'n/a'} (reason: ${reasonB}).`;
});

function pickFacility(originLngLat, fc, floodPolys){
  if(!fc?.features?.length) return null;
  const p0=turf.point(originLngLat);
  const avoid = floodPolys.length>0;
  let best=null, bestD=Infinity, filtered=0;
  for(const f of fc.features){
    const p=f.geometry?.coordinates; if(!p) continue;
    if(avoid && floodPolys.some(poly=>turf.booleanPointInPolygon(turf.point(p), poly))){ filtered++; continue; }
    const d=turf.distance(p0, turf.point(p), {units:'miles'});
    if(d<bestD){best=f;bestD=d;}
  }
  if(!best){ // all filtered? choose nearest anyway
    for(const f of fc.features){
      const p=f.geometry?.coordinates; if(!p) continue;
      const d=turf.distance(p0, turf.point(p), {units:'miles'});
      if(d<bestD){best=f;bestD=d;}
    }
  }
  return {feature:best, explain: avoid ? (filtered>0 ? 'nearest outside flood polygons' : 'nearest (no facilities in flood)') : 'nearest by distance'};
}

async function routeOSRM(a,b,floodPolys){
  try{
    const url = `${OSRM_BASE}/route/v1/driving/${a[0]},${a[1]};${b[0]},${b[1]}?overview=full&geometries=geojson&alternatives=true&steps=false`;
    const res = await fetch(url);
    const j = await res.json();
    const routes = (j.routes || []).map(r=>({
      geom: turf.lineString(r.geometry.coordinates),
      dist: r.distance/1609.344,
      eta:  r.duration/60
    }));
    if(!routes.length) return null;

    function floodOverlap(line){
      if(!floodPolys.length) return 0;
      let total=0;
      const segs = turf.segmentReduce(line,(acc,cur)=>{ acc.push(cur); return acc; },[]);
      for(const s of segs){
        if(floodPolys.some(poly=>turf.booleanWithin(turf.midpoint(s.geometry.coordinates[0],s.geometry.coordinates[1]), poly))){
          total += turf.length(s,{units:'miles'});
        }
      }
      return total;
    }
    let best=routes[0], score=floodOverlap(routes[0].geom);
    for(let i=1;i<routes.length;i++){ const s=floodOverlap(routes[i].geom); if(s<score){best=routes[i]; score=s;} }
    best.reason = (floodPolys.length? (score>0?'minimized flooded overlap':'avoided flooded areas') : 'shortest-time from OSRM');
    return best;
  }catch(err){ console.warn('OSRM route failed:', err); return null; }
}

/* -------- UI -------- */
document.getElementById('toggleNFHL').addEventListener('click', e=>{
  e.currentTarget.classList.toggle('active');
  map.setLayoutProperty('nfhl','visibility', e.currentTarget.classList.contains('active')?'visible':'none');
});
document.getElementById('toggleFuture').addEventListener('click', e=>{
  e.currentTarget.classList.toggle('active');
  map.setLayoutProperty('future','visibility', e.currentTarget.classList.contains('active')?'visible':'none');
});
document.getElementById('floodOpacity').addEventListener('input', e=>{
  const v=+e.target.value; if(map.getLayer('nfhl')) map.setPaintProperty('nfhl','fill-opacity', v);
  if(map.getLayer('future')) map.setPaintProperty('future','fill-opacity', v);
});
document.getElementById('colorMetric').addEventListener('click', ()=>setColorMode('metric'));
document.getElementById('colorWeight').addEventListener('click', ()=>setColorMode('weight'));

/* -------- Edge property table / tip -------- */
const tipEl=document.getElementById('tip'); const propsEl=document.getElementById('propTable');
let showRaw=false, lastProps=null, lastPinned=false;
document.getElementById('toggleRaw').addEventListener('click', e=>{
  e.preventDefault(); showRaw=!showRaw; if(lastProps) propsEl.innerHTML=renderTable(showRaw?lastProps:cleanProps(lastProps));
});
map.on('mousemove', e=>{
  const f=map.queryRenderedFeatures(e.point,{layers:['edges-line']})[0];
  if(!f){ if(!lastPinned) tipEl.classList.add('hidden'); return; }
  const nm=f.properties?.name||f.properties?.ref||'Edge';
  tipEl.innerHTML=`<strong>${esc(nm)}</strong>`;
  tipEl.style.left=e.originalEvent.clientX+'px'; tipEl.style.top=e.originalEvent.clientY+'px';
  tipEl.classList.remove('hidden');
});
function esc(s){return String(s).replace(/[&<>"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));}
const FIX_LABELS={ id:'ID', name:'Name', ref:'Ref', functional_class:'Class',
  oneway:'Direction', one_way:'Direction', is_oneway:'Direction', direction:'Direction',
  lanes:'Lanes', maxspeed:'Max speed', surface:'Surface', divided:'Divided', zipcode:'ZIP'
};
function cleanProps(p){
  const out={}; if(!p) return out;
  const keys=new Set(['eid','id','name','ref','functional_class','oneway','one_way','is_oneway','direction','lanes','maxspeed','surface','divided','zipcode']);
  for(const k of keys){ if(!k||!(k in p)) continue;
    let label=FIX_LABELS[k]||k, v=p[k];
    if(label==='Direction'){ const s=String(v).toLowerCase(); v=(s==='yes'||s==='true'||s==='1'||s==='y'||s==='one-way')?'One-way':'Two-way'; }
    if(label==='Max speed'&&v) v=`${v} mph`;
    out[label]=v;
  }
  return out;
}
function renderTable(obj){
  if(showRaw){ return `<pre style="white-space:pre-wrap;margin:0">${esc(JSON.stringify(obj,null,2))}</pre>`; }
  const keys=Object.keys(obj); if(!keys.length) return '(no selected fields)';
  let h='<table>'; for(const k of keys){ h+=`<tr><td>${esc(k)}</td><td>${esc(obj[k])}</td></tr>` } return h+'</table>';
}
function throttle(fn,wait){let t=0;return(...a)=>{const n=Date.now();if(n-t>wait){t=n;fn(...a);}}}
map.on('error', e=>console.error('Map error:', e?.error||e));
})();
</script>
</body>
</html>
