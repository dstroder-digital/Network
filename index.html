<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Charlotte Network Explorer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    :root{
      --bg:#0b0f17;--panel:#0c101c;--text:#e0e6ff;--accent:#8cf;
      --line1:#7aa2c8;--line2:#3f8fc9;--line3:#0d3b66;
      --cyan:#00ffff;--mag:#ff00ff;--glow:0 0 40px rgba(0,255,255,.15), inset 0 0 36px rgba(255,0,255,.05);
    }
    html,body {height:100%;margin:0;background:var(--bg);color:var(--text);font-family:Inter,system-ui,Segoe UI,Roboto,sans-serif}
    #app {display:grid;grid-template-columns:2fr 1fr;height:100%}
    #map {position:relative}
    #panel {border-left:1px solid #243;background:rgba(12,16,28,.9);backdrop-filter:blur(8px);padding:12px;overflow:auto;box-shadow:var(--glow)}
    h3{margin:6px 0;color:var(--accent);text-shadow:0 0 8px rgba(0,200,255,.5)}
    .tag{display:inline-block;border:1px solid #2a4a70;border-radius:999px;padding:2px 8px;margin:0 6px 6px 0;color:#bfe}
    .btn{background:#122034;color:#bfe;border:1px solid #2a4a70;border-radius:8px;padding:6px 10px;cursor:pointer;margin:4px 2px}
    .btn:hover{background:#1a2c48}
    .legend{font-size:12px;line-height:1.6;margin-top:6px}
    .sw{display:inline-block;width:16px;height:3px;margin-right:6px;vertical-align:middle;box-shadow:0 0 8px currentColor}
    .hudline{height:1px;background:#1b2638;margin:8px 0}
    /* leaflet tooltip restyle */
    .leaflet-tooltip{background:rgba(12,16,28,.9);border:1px solid #2a4a70;color:#e0e6ff;box-shadow:0 0 12px rgba(0,255,255,.2)}
  </style>
</head>
<body>
<div id="app">
  <div id="map"></div>
  <div id="panel">
    <h3>Charlotte Network</h3>
    <div id="summary">Loadingâ€¦</div>
    <div class="hudline"></div>
    <div style="margin:6px 0">
      <button class="btn" id="btnRoutes">Toggle Example Route</button>
      <button class="btn" id="btnFloods">Toggle Flood Layers</button>
    </div>
    <div class="legend">
      <div><span class="sw" style="color:var(--cyan);background:var(--cyan)"></span>Baseline route</div>
      <div><span class="sw" style="color:var(--mag);background:var(--mag)"></span>Flooded route</div>
    </div>
    <div class="hudline"></div>
    <div id="details"><b>Hint:</b> hover a street or intersection for details. Click to lock.</div>
    <div class="hudline"></div>
    <div id="rstats"></div>
    <div style="margin-top:8px">
      <span class="tag">Edge width â‰ˆ latest counts</span>
      <span class="tag">Arrows = one-way</span>
      <span class="tag">Flood overlay toggle</span>
    </div>
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/d3@7.9.0/dist/d3.min.js"></script>
<script>
(async function(){
  // ---- data paths (relative to docs/) ----
  const ROOT = './data/app';
  const files = {
    nodes:  `${ROOT}/nodes.geojson`,
    edges:  `${ROOT}/edges.geojson`,
    fire:   `${ROOT}/fire_stations.geojson`,
    med:    `${ROOT}/medical_facilities.geojson`,
    nfhl:   `${ROOT}/nfhl_dissolved.geojson`,
    fut:    `${ROOT}/future_flood_dissolved.geojson`,
    rBase:  `${ROOT}/route_example_baseline.geojson`,
    rFlood: `${ROOT}/route_example_flooded.geojson`,
    rStat:  `${ROOT}/route_example_stats.json`
  };

  // ---- map ----
  const map = L.map('map', { zoomControl:false }).setView([35.2271, -80.8431], 12);
  L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
    attribution:'&copy; OSM & CARTO'
  }).addTo(map);
  L.control.zoom({ position:"bottomright" }).addTo(map);

  // ---- svg overlay for edges/intersections (fast hover) ----
  const svgLayer = L.svg({ clickable:true }).addTo(map);
  const svg = d3.select(svgLayer._svg).attr("pointer-events","auto");
  const gEdges = svg.append("g").attr("class","edges");
  const gNodes = svg.append("g").attr("class","nodes");
  const gArrows= svg.append("g").attr("class","arrows");

  // helpers
  const geoProject = d3.geoPath().projection(d3.geoTransform({
    point: function(x,y){ const p = map.latLngToLayerPoint([y,x]); this.stream.point(p.x,p.y); }
  }));
  function lineWidth(w){ return Math.max(1, Math.min(6, +w || 1)); }
  function colorByBetQ(q){
    const v = +q||0;
    return v<16000? '#7aa2c8' : v<48000? '#3f8fc9' : '#0d3b66';
  }

  const [edges, nodes] = await Promise.all([
    fetch(files.edges).then(r=>r.json()),
    fetch(files.nodes).then(r=>r.json())
  ]);

  // summary
  document.getElementById('summary').innerHTML =
    `Segments: ${edges.features.length.toLocaleString()} &nbsp;|&nbsp; Intersections: ${nodes.features.length.toLocaleString()}`;

  // draw edges
  function drawEdges(){
    const sel = gEdges.selectAll("path.edge").data(edges.features, d=>d.properties.eid);
    sel.enter().append("path")
      .attr("class","edge")
      .attr("stroke","#66eeff")
      .attr("fill","none")
      .attr("stroke-opacity",0.45)
      .attr("d", d=>geoProject(d))
      .attr("stroke-width", d=>lineWidth(d.properties.width))
      .on("mousemove", (ev,d)=> showStreetDetails(d.properties, ev))
      .on("click", (ev,d)=> lockDetails(d.properties));
    sel.attr("d", d=>geoProject(d))
       .attr("stroke-width", d=>lineWidth(d.properties.width));
    sel.exit().remove();
  }

  // draw nodes (intersections)
  function drawNodes(){
    const pts = nodes.features.map(f=>{
      const [x,y]=f.geometry.coordinates; const p=map.latLngToLayerPoint([y,x]);
      return {x:p.x,y:p.y,deg:f.properties.degree||f.properties.deg||0, clo_q:f.properties.closeness||f.properties.clo_q||0};
    });
    const sel = gNodes.selectAll("circle.n").data(pts);
    sel.enter().append("circle").attr("class","n")
      .attr("r",2.2).attr("fill","#e0f7ff").attr("opacity",0.9)
      .attr("cx",d=>d.x).attr("cy",d=>d.y)
      .on("mousemove",(ev,d)=> showNodeDetails(d))
      .on("click",(ev,d)=> lockDetails(d));
    sel.attr("cx",d=>d.x).attr("cy",d=>d.y);
    sel.exit().remove();
  }

  // one-way arrows (optional if you provided a per-edge oneway flag)
  function drawArrows(){
    const A=6;
    const arr = edges.features.map(f=>{
      const g = f.geometry;
      if (g.type!=='LineString') return null;
      const c = g.coordinates;
      if (c.length<2) return null;
      const mid = c[Math.floor(c.length/2)];
      const p = map.latLngToLayerPoint([mid[1], mid[0]]);
      return {x:p.x,y:p.y};
    }).filter(Boolean);
    const sel = gArrows.selectAll("polygon.arrow").data(arr);
    sel.enter().append("polygon").attr("class","arrow")
      .attr("fill","#9ff").attr("opacity",0.8)
      .attr("points",d=>`${d.x},${d.y-A} ${d.x+A},${d.y+A} ${d.x-A},${d.y+A}`);
    sel.attr("points",d=>`${d.x},${d.y-A} ${d.x+A},${d.y+A} ${d.x-A},${d.y+A}`);
    sel.exit().remove();
  }

  function redraw(){ drawEdges(); drawNodes(); drawArrows(); }
  map.on("moveend zoomend", redraw);
  redraw();

  // POIs
  const fireIcon = L.divIcon({html:"ðŸš’", className:"", iconSize:[22,22], iconAnchor:[11,11]});
  const hospIcon = L.divIcon({html:"ðŸ¥", className:"", iconSize:[22,22], iconAnchor:[11,11]});
  try {
    const fire = await (await fetch(files.fire)).json();
    L.geoJSON(fire, { pointToLayer:(_,latlng)=>L.marker(latlng,{icon:fireIcon}) }).addTo(map);
  } catch(e){}
  try {
    const med  = await (await fetch(files.med)).json();
    L.geoJSON(med,  { pointToLayer:(_,latlng)=>L.marker(latlng,{icon:hospIcon}) }).addTo(map);
  } catch(e){}

  // Flood overlays (toggle)
  let floodLayers=[];
  function addFloodLayers(){
    floodLayers.forEach(l=>map.removeLayer(l)); floodLayers=[];
    Promise.all([
      fetch(files.nfhl).then(r=>r.ok?r.json():null),
      fetch(files.fut ).then(r=>r.ok?r.json():null)
    ]).then(([nfhl,fut])=>{
      if (nfhl) floodLayers.push(L.geoJSON(nfhl,{style:{color:'#00ffff',weight:1,opacity:.8,fillOpacity:.15}}).addTo(map));
      if (fut)  floodLayers.push(L.geoJSON(fut, {style:{color:'#ff00ff',weight:1,opacity:.8,fillOpacity:.12}}).addTo(map));
    });
  }
  let floodsOn=false;
  document.getElementById('btnFloods').onclick=()=>{ floodsOn=!floodsOn; floodsOn?addFloodLayers():floodLayers.forEach(l=>map.removeLayer(l)); };

  // Example routes (toggle)
  let routeOn=false, routeLayers=[];
  document.getElementById('btnRoutes').onclick=async ()=>{
    const rstats = document.getElementById('rstats');
    if(routeOn){ routeLayers.forEach(l=>map.removeLayer(l)); routeLayers=[]; routeOn=false; rstats.textContent=''; return; }
    try{
      const [r0, r1, stats] = await Promise.all([
        fetch(files.rBase).then(r=>r.json()),
        fetch(files.rFlood).then(r=>r.json()),
        fetch(files.rStat).then(r=>r.json()).catch(()=>({}))
      ]);
      const l0 = L.geoJSON(r0, { style:{color:'var(--cyan)', weight:4, opacity:.9} }).addTo(map);
      const l1 = L.geoJSON(r1, { style:{color:'var(--mag)',  weight:4, opacity:.9} }).addTo(map);
      routeLayers=[l0,l1]; routeOn=true;
      const grp = L.featureGroup(routeLayers); map.fitBounds(grp.getBounds(), {maxZoom:14});
      const pad = s => (s==null||!isFinite(s))? 'â€”' : (s/60).toFixed(1)+' min';
      rstats.innerHTML = `<div><b>Baseline:</b> ${pad(stats.baseline_sec)}</div>
                          <div><b>Flooded:</b> ${pad(stats.flooded_sec)}</div>
                          <div><b>Î” Time:</b> ${pad(stats.delta_sec)}</div>`;
    }catch(e){ rstats.textContent='Route example files not found.'; }
  };

  // hover + details
  const details = document.getElementById('details');
  let locked=false;
  function showStreetDetails(p, ev){
    if(locked) return;
    details.innerHTML = `<b>Street</b><br>
      Betweenness (q16): ${p.bet_q ?? 'â€”'} &nbsp;|&nbsp; Width: ${(+p.width||0).toFixed(1)}<br>
      ${p.blocked_future? 'âš  Flood-prone segment' : ''}`;
    // tooltip near cursor
    const tt = L.tooltip({permanent:false,direction:'top',opacity:.9})
      .setLatLng(map.layerPointToLatLng(L.point(ev.offsetX,ev.offsetY)))
      .setContent('segment: '+(p.eid ?? 'â€”'));
    map.openTooltip(tt);
    clearTimeout(showStreetDetails._t); showStreetDetails._t=setTimeout(()=>map.closeTooltip(tt), 600);
  }
  function showNodeDetails(p){
    if(locked) return;
    details.innerHTML = `<b>Intersection</b><br>Degree: ${p.deg??'â€”'} &nbsp;|&nbsp; Closeness (q16): ${p.clo_q??'â€”'}`;
  }
  function lockDetails(p){ locked = !locked; }

  // keep SVG aligned
  function syncSvgSize(){
    const size = map.getSize();
    svg.attr("width", size.x).attr("height", size.y);
  }
  map.on('resize', syncSvgSize); syncSvgSize();

})();
</script>
</body>
</html>

